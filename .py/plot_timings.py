#!/usr/bin/env python3
"""
generate_report.py
Создаёт краткий Markdown-отчёт по анализу алгоритмов умножения матриц
в файле ../data/report.md (относительно папки .py).
"""

from pathlib import Path

# Папка .py
PY_DIR = Path(__file__).resolve().parent
# Корень проекта (папка уровнем выше)
PROJECT_ROOT = PY_DIR.parent
# data/ в корне проекта
DATA_DIR = PROJECT_ROOT / "data"
REPORT_PATH = DATA_DIR / "report.md"


def main():
    DATA_DIR.mkdir(parents=True, exist_ok=True)

    report_md = """# Анализ алгоритмов умножения матриц

## 1. Цель работы

Сравнить три подхода к умножению матриц:
1. стандартный алгоритм на C++;
2. алгоритм Штрассена на C++;
3. реализацию умножения на Python/NumPy.

Оценить их **теоретическую асимптотическую сложность** и проверить её на практике с помощью измерений времени работы.

---

## 2. Теоретический анализ сложности

### 2.1. Стандартный алгоритм

**Асимптотическая сложность (теоретическая):**
\\[
T(n) = O(n^3).
\\]

Алгоритм реализован тройным вложенным циклом, каждый из \\(n^2\\) элементов результирующей матрицы требует \\(n\\) операций умножения и сложения, что даёт порядок \\(n^3\\).

### 2.2. Алгоритм Штрассена

**Рекуррентное соотношение:**
\\[
T(n) = 7T\\left(\\frac{n}{2}\\right) + O(n^2),
\\]
где \\(O(n^2)\\) — стоимость сложений и вычитаний блоков.

Решение рекуррентного соотношения даёт теоретическую оценку сложности:
\\[
T(n) = O\\left(n^{\\log_2 7}\\right) \\approx O(n^{2.807}).
\\]

### 2.3. Умножение матриц в NumPy

Функции `np.dot(A, B)` и `A @ B` используют оптимизированные библиотеки линейной алгебры (BLAS/LAPACK). Для плотных матриц их теоретическая сложность имеет порядок
\\[
T(n) = O(n^3),
\\]
но с меньшими константами, чем у наивной реализации на C++.

---

## 3. Экспериментальные данные и визуализация

Для проверки теоретических оценок сложности проведены измерения времени работы алгоритмов для нескольких значений размера матриц \\(n\\).
Результаты сохранены в:

- `data/csv/timings.csv` — стандартный алгоритм C++ и алгоритм Штрассена;
- `data/csv/timings_numpy.csv` — умножение матриц в NumPy.

На основе этих данных построены графики:

- `data/png/timings_standard.png` — время работы стандартного алгоритма;
- `data/png/timings_strassen.png` — время работы алгоритма Штрассена;
- `data/png/timings_numpy.png` — время работы NumPy;
- `data/png/timings_all.png` — сравнение всех трёх алгоритмов (линейный масштаб);
- `data/png/timings_all_loglog.png` — сравнение всех трёх алгоритмов в логарифмическом масштабе.

На графике `timings_all_loglog.png` точки для стандартного алгоритма и алгоритма Штрассена лежат вдоль кривых, форма которых согласуется с теоретическими оценками \\(O(n^3)\\) и \\(O(n^{\\log_2 7})\\).
Таким образом, **асимптотические оценки получены теоретически, а экспериментальные данные подтверждают их характер роста**.

Дополнительно построены теоретические графики:

- `data/png/complexity_theory.png` — функции \\(n^3\\) и \\(n^{\\log_2 7}\\), их отношение и теоретическая экономия операций;
- `data/png/complexity_theory_loglog.png` — теоретическое отношение сложностей в лог-лог масштабе;
- `data/png/complexity_saving_bar.png` — теоретическая экономия операций алгоритмом Штрассена (в процентах).

---

## 4. Сравнительный анализ

- Теоретически стандартный алгоритм имеет сложность \\(O(n^3)\\), а алгоритм Штрассена — \\(O(n^{\\log_2 7})\\), что даёт более медленный рост числа операций при больших \\(n\\).
- По экспериментальным данным алгоритм Штрассена медленнее стандартного на малых размерах матриц из-за накладных расходов рекурсивных вызовов и работы с блоками.
- Реализация в NumPy показывает наименьшее время выполнения для протестированных размеров матриц благодаря использованию оптимизированных библиотек.

---

## 5. Выводы

1. Асимптотические оценки сложности \\(O(n^3)\\) для стандартного алгоритма и \\(O(n^{\\log_2 7})\\) для алгоритма Штрассена получены из теоретического анализа и подтверждаются характером роста времени на графике `timings_all_loglog.png`.
2. На малых размерах матриц стандартный алгоритм C++ работает быстрее алгоритма Штрассена, что объясняется высокими постоянными факторами у рекурсивного алгоритма.
3. Умножение матриц в NumPy демонстрирует лучшую практическую производительность среди рассматриваемых реализаций.
4. Для небольших матриц целесообразно использовать стандартный алгоритм, для больших — алгоритмы с меньшей асимптотикой, а в прикладных задачах на практике — библиотечные реализации (например, NumPy/BLAS).

"""

    REPORT_PATH.write_text(report_md, encoding="utf-8")
    print(f"Отчёт сгенерирован: {REPORT_PATH}")


if __name__ == "__main__":
    main()
