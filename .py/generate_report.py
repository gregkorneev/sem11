#!/usr/bin/env python3
"""
generate_report.py
Создаёт краткий Markdown-отчёт по анализу алгоритмов умножения матриц
в файле ../data/report.md (относительно папки .py).
"""

from pathlib import Path

# Папка .py
PY_DIR = Path(__file__).resolve().parent
# Корень проекта (папка уровнем выше)
PROJECT_ROOT = PY_DIR.parent
# data/ в корне проекта
DATA_DIR = PROJECT_ROOT / "data"
REPORT_PATH = DATA_DIR / "report.md"


def main():
    DATA_DIR.mkdir(parents=True, exist_ok=True)

    report_md = """# Анализ алгоритмов умножения матриц

## 1. Цель работы

Сравнить три подхода к умножению матриц:
1. стандартный алгоритм на C++;
2. алгоритм Штрассена на C++;
3. реализацию умножения на Python/NumPy.

Оценить их теоретическую асимптотическую сложность и проверить её на практике с помощью измерений времени работы.

---

## 2. Теоретический анализ сложности

### 2.1. Стандартный алгоритм

Асимптотическая сложность (теоретическая): **T(n) = O(n^3)**.

Алгоритм реализован тройным вложенным циклом. Каждый из n² элементов результирующей матрицы C вычисляется как скалярное произведение строки матрицы A и столбца матрицы B:

C_ij = Σ_{k=1..n} A_ik * B_kj.

Итого порядок числа операций — n³.

### 2.2. Алгоритм Штрассена

Рекуррентное соотношение для времени работы:

T(n) = 7 · T(n/2) + O(n^2),

где O(n^2) — стоимость сложений и вычитаний блоков.

Из него теоретически выводится сложность:

T(n) = O(n^{log2 7}) ≈ O(n^{2.807}).

### 2.3. Умножение матриц в NumPy

Функции `np.dot(A, B)` и `A @ B` используют оптимизированные библиотеки линейной алгебры (BLAS/LAPACK).
Для плотных матриц их теоретическая сложность также имеет порядок T(n) = O(n^3), но константы существенно меньше, чем у наивной реализации на C++.

---

## 3. Экспериментальные данные и визуализация

Для проверки теоретических оценок сложности проведены измерения времени работы алгоритмов для нескольких значений размера матриц n.
Результаты сохранены в файлах:

- `data/csv/timings.csv` — стандартный алгоритм C++ и алгоритм Штрассена;
- `data/csv/timings_numpy.csv` — умножение матриц в NumPy.

На основе этих данных построены графики:

- `data/png/timings_standard.png` — время работы стандартного алгоритма;
- `data/png/timings_strassen.png` — время работы алгоритма Штрассена;
- `data/png/timings_numpy.png` — время работы NumPy;
- `data/png/timings_all.png` — сравнение всех трёх алгоритмов (линейный масштаб);
- `data/png/timings_all_loglog.png` — сравнение всех трёх алгоритмов в логарифмическом масштабе.

На графике `timings_all_loglog.png` видно, что кривые для стандартного алгоритма и алгоритма Штрассена растут в соответствии с теоретическими оценками O(n^3) и O(n^{log2 7}).
Асимптотические оценки получены из анализа алгоритмов, а экспериментальные данные подтверждают характер их роста.

Дополнительно построены теоретические графики:

- `data/png/complexity_theory.png` — функции n^3 и n^{log2 7}, их отношение и теоретическая экономия операций;
- `data/png/complexity_theory_loglog.png` — теоретическое отношение сложностей в логарифмическом масштабе;
- `data/png/complexity_saving_bar.png` — теоретическая экономия операций алгоритмом Штрассена (в процентах).

---

## 4. Сравнительный анализ

- Теоретически стандартный алгоритм имеет сложность O(n^3), а алгоритм Штрассена — O(n^{log2 7}), то есть число операций растёт медленнее при больших n.
- По экспериментальным данным алгоритм Штрассена медленнее стандартного на малых размерах матриц из-за накладных расходов рекурсии и работы с блоками.
- Реализация в NumPy показывает наименьшее время выполнения для протестированных размеров матриц благодаря использованию оптимизированных библиотек.

---

## 5. Выводы

1. Асимптотические оценки сложности O(n^3) для стандартного алгоритма и O(n^{log2 7}) для алгоритма Штрассена получены теоретически и подтверждаются характером роста времени на графике `timings_all_loglog.png`.
2. На малых размерах матриц стандартный алгоритм C++ работает быстрее алгоритма Штрассена из-за больших постоянных факторов у рекурсивного алгоритма.
3. Умножение матриц в NumPy демонстрирует лучшую практическую производительность среди рассматриваемых реализаций.
4. Для небольших матриц целесообразно использовать стандартный алгоритм, для очень больших — алгоритмы с меньшей асимптотикой, а в прикладных задачах на практике — библиотечные реализации (например, NumPy/BLAS).

"""

    REPORT_PATH.write_text(report_md, encoding="utf-8")
    print(f"Отчёт сгенерирован: {REPORT_PATH}")


if __name__ == "__main__":
    main()
